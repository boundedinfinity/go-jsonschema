//************************************************************************************
//*                                                                                  *
//* ===== DO NOT EDIT =====                                                          *
//* Manual changes will be overwritten.                                              *
//* Generated by github.com/boundedinfinity/enumer                                   *
//*                                                                                  *
//************************************************************************************

package idiomatic

import (
	"database/sql/driver"
	"fmt"

	"github.com/boundedinfinity/enumer"
)

type StringFormat string

// /////////////////////////////////////////////////////////////////
//  StringFormat Stringer implemenation
// /////////////////////////////////////////////////////////////////

func (t StringFormat) String() string {
	return string(t)
}

// /////////////////////////////////////////////////////////////////
//  StringFormat JSON marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t StringFormat) MarshalJSON() ([]byte, error) {
	return enumer.MarshalJSON(t)
}

func (t *StringFormat) UnmarshalJSON(data []byte) error {
	return enumer.UnmarshalJSON(data, t, StringFormats.Parse)
}

// /////////////////////////////////////////////////////////////////
//  StringFormat YAML marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t StringFormat) MarshalYAML() (interface{}, error) {
	return enumer.MarshalYAML(t)
}

func (t *StringFormat) UnmarshalYAML(unmarshal func(interface{}) error) error {
	return enumer.UnmarshalYAML(unmarshal, t, StringFormats.Parse)
}

// /////////////////////////////////////////////////////////////////
//  StringFormat SQL Database marshal/unmarshal implemenation
// /////////////////////////////////////////////////////////////////

func (t StringFormat) Value() (driver.Value, error) {
	return enumer.Value(t)
}

func (t *StringFormat) Scan(value interface{}) error {
	return enumer.Scan(value, t, StringFormats.Parse)
}

// /////////////////////////////////////////////////////////////////
//
//  Enumeration
//
// /////////////////////////////////////////////////////////////////

type stringFormats struct {
	DateTime            StringFormat
	Time                StringFormat
	Date                StringFormat
	Duration            StringFormat
	Email               StringFormat
	IdnEmail            StringFormat
	Hostname            StringFormat
	IdnHostname         StringFormat
	Ipv4                StringFormat
	Ipv6                StringFormat
	Uuid                StringFormat
	Uri                 StringFormat
	UriReference        StringFormat
	UriTemplate         StringFormat
	Iri                 StringFormat
	IriReference        StringFormat
	JsonPointer         StringFormat
	RelativeJsonPointer StringFormat
	Regex               StringFormat
	Values              []StringFormat
	Err                 error
}

var StringFormats = stringFormats{
	DateTime:            StringFormat("date-time"),
	Time:                StringFormat("time"),
	Date:                StringFormat("date"),
	Duration:            StringFormat("duration"),
	Email:               StringFormat("email"),
	IdnEmail:            StringFormat("idn-email"),
	Hostname:            StringFormat("hostname"),
	IdnHostname:         StringFormat("idn-hostname"),
	Ipv4:                StringFormat("ipv-4"),
	Ipv6:                StringFormat("ipv-6"),
	Uuid:                StringFormat("uuid"),
	Uri:                 StringFormat("uri"),
	UriReference:        StringFormat("uri-reference"),
	UriTemplate:         StringFormat("uri-template"),
	Iri:                 StringFormat("iri"),
	IriReference:        StringFormat("iri-reference"),
	JsonPointer:         StringFormat("json-pointer"),
	RelativeJsonPointer: StringFormat("relative-json-pointer"),
	Regex:               StringFormat("regex"),
	Err:                 fmt.Errorf("invalid StringFormat"),
}

func init() {
	StringFormats.Values = []StringFormat{
		StringFormats.DateTime,
		StringFormats.Time,
		StringFormats.Date,
		StringFormats.Duration,
		StringFormats.Email,
		StringFormats.IdnEmail,
		StringFormats.Hostname,
		StringFormats.IdnHostname,
		StringFormats.Ipv4,
		StringFormats.Ipv6,
		StringFormats.Uuid,
		StringFormats.Uri,
		StringFormats.UriReference,
		StringFormats.UriTemplate,
		StringFormats.Iri,
		StringFormats.IriReference,
		StringFormats.JsonPointer,
		StringFormats.RelativeJsonPointer,
		StringFormats.Regex,
	}
}

func (t stringFormats) newErr(a any, values ...StringFormat) error {
	return fmt.Errorf(
		"invalid %w value '%v'. Must be one of %v",
		StringFormats.Err,
		a,
		enumer.Join(values, ", "),
	)
}

func (t stringFormats) ParseFrom(v string, values ...StringFormat) (StringFormat, error) {
	var found StringFormat
	var ok bool

	for _, value := range values {
		if enumer.IsEq[string, StringFormat](v)(value) {
			found = value
			ok = true
			break
		}
	}

	if !ok {
		return found, t.newErr(v, values...)
	}

	return found, nil
}

func (t stringFormats) Parse(v string) (StringFormat, error) {
	return t.ParseFrom(v, StringFormats.Values...)
}

func (t stringFormats) IsFrom(v string, values ...StringFormat) bool {
	for _, value := range values {
		if enumer.IsEq[string, StringFormat](v)(value) {
			return true
		}
	}
	return false
}

func (t stringFormats) Is(v string) bool {
	return t.IsFrom(v, StringFormats.Values...)
}
