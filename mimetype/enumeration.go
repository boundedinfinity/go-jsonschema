//************************************************************************************
//*                                                                                  *
//* ===== DO NOT EDIT =====                                                          *
//* Any change will be overwritten                                                   *
//* Generated by github.com/boundedinfinity/enumer                                   *
//*                                                                                  *
//************************************************************************************

package mimetype

import (
	"encoding/json"
	"errors"
	"fmt"
	"strings"
)

type MimeType string
type MimeTypes []MimeType

func Slice(es ...MimeType) MimeTypes {
	var s MimeTypes

	for _, e := range es {
		s = append(s, e)
	}

	return s
}

const (
	ApplicationEcmascript  MimeType = "application/ecmascript"
	ApplicationJavascript  MimeType = "application/javascript"
	ApplicationJson        MimeType = "application/json"
	ApplicationOgg         MimeType = "application/ogg"
	ApplicationXEcmascript MimeType = "application/x-ecmascript"
	ApplicationXJavascript MimeType = "application/x-javascript"
	ApplicationXJson       MimeType = "application/x-json"
	ApplicationXYaml       MimeType = "application/x-yaml"
	ApplicationYaml        MimeType = "application/yaml"
	AudioOgg               MimeType = "audio/ogg"
	AudioWav               MimeType = "audio/wav"
	AudioWave              MimeType = "audio/wave"
	AudioWebm              MimeType = "audio/webm"
	AudioXPnWav            MimeType = "audio/x-pn-wav"
	AudioXWav              MimeType = "audio/x-wav"
	MultipartByteranges    MimeType = "multipart/byteranges"
	MultipartFormData      MimeType = "multipart/form-data"
	TextCss                MimeType = "text/css"
	TextEcmascript         MimeType = "text/ecmascript"
	TextHtml               MimeType = "text/html"
	TextJavascript         MimeType = "text/javascript"
	TextJavascript10       MimeType = "text/javascript1.0"
	TextJavascript11       MimeType = "text/javascript1.1"
	TextJavascript12       MimeType = "text/javascript1.2"
	TextJavascript13       MimeType = "text/javascript1.3"
	TextJavascript14       MimeType = "text/javascript1.4"
	TextJavascript15       MimeType = "text/javascript1.5"
	TextJscript            MimeType = "text/jscript"
	TextJson               MimeType = "text/json"
	TextLivescript         MimeType = "text/livescript"
	TextPlain              MimeType = "text/plain"
	TextXEcmascript        MimeType = "text/x-ecmascript"
	TextXJavascript        MimeType = "text/x-javascript"
	TextXJson              MimeType = "text/x-json"
	TextXYaml              MimeType = "text/x-yaml"
	TextYaml               MimeType = "text/yaml"
	VideoOgg               MimeType = "video/ogg"
	VideoWebm              MimeType = "video/webm"
)

var (
	All = MimeTypes{
		ApplicationEcmascript,
		ApplicationJavascript,
		ApplicationJson,
		ApplicationOgg,
		ApplicationXEcmascript,
		ApplicationXJavascript,
		ApplicationXJson,
		ApplicationXYaml,
		ApplicationYaml,
		AudioOgg,
		AudioWav,
		AudioWave,
		AudioWebm,
		AudioXPnWav,
		AudioXWav,
		MultipartByteranges,
		MultipartFormData,
		TextCss,
		TextEcmascript,
		TextHtml,
		TextJavascript,
		TextJavascript10,
		TextJavascript11,
		TextJavascript12,
		TextJavascript13,
		TextJavascript14,
		TextJavascript15,
		TextJscript,
		TextJson,
		TextLivescript,
		TextPlain,
		TextXEcmascript,
		TextXJavascript,
		TextXJson,
		TextXYaml,
		TextYaml,
		VideoOgg,
		VideoWebm,
	}
)

func Is(v string) bool {
	return All.Is(v)
}

func Parse(v string) (MimeType, error) {
	return All.Parse(v)
}

func Strings() []string {
	return All.Strings()
}

func (t MimeType) String() string {
	return string(t)
}

var ErrMimeTypeInvalid = errors.New("invalid enumeration type")

func Error(vs MimeTypes, v string) error {
	return fmt.Errorf(
		"%w '%v', must be one of %v",
		ErrMimeTypeInvalid, v, strings.Join(vs.Strings(), ","),
	)
}

func (t MimeTypes) Strings() []string {
	var ss []string

	for _, v := range t {
		ss = append(ss, v.String())
	}

	return ss
}

func (t MimeTypes) Parse(v string) (MimeType, error) {
	var o MimeType
	var f bool
	n := strings.ToLower(v)

	for _, e := range t {
		if strings.ToLower(e.String()) == n {
			o = e
			f = true
			break
		}
	}

	if !f {
		return o, Error(t, v)
	}

	return o, nil
}

func (t MimeTypes) Is(v string) bool {
	var f bool

	for _, e := range t {
		if string(e) == v {
			f = true
			break
		}
	}

	return f
}

func (t MimeTypes) Contains(v MimeType) bool {
	for _, e := range t {
		if e == v {
			return true
		}
	}

	return false
}

func (t MimeType) MarshalJSON() ([]byte, error) {
	return json.Marshal(string(t))
}

func (t *MimeType) UnmarshalJSON(data []byte) error {
	var s string

	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}

	e, err := Parse(s)

	if err != nil {
		return err
	}

	*t = e

	return nil
}
